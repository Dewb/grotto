<!DOCTYPE html>
<html lang="en">
	<head>
		<title>liquid grotto simulator</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		
		<!-- simulator for Doug Ruuska's Liquid Grotto -->
		<!-- by Dewb 4/14/2013 -->
		<!-- adapted from Three.js sample webgl_interactive_cubes_gpu -->
		
		<style>
			body {
				font-family: helvetica;
				font-weight: 100;
				background-color: #303030;
				margin: 0px;
				overflow: hidden;
			}

			.info {
				position: absolute;
				background-color: black;
				opacity: 0.65;
				color: white;
				text-align: center;
				top: 0px;
				width: 100%;
				font-size: 22pt;
				padding: 7px 0 7px 0;
			}
			
			.notes {
				position: absolute;
				top: 2px;
				left: 95px;
				font-size: 7pt;
				color: silver;
			}

			.info a {
				color: #00ffff;
			}
			
			div a {
			 	color: white;
			    text-decoration: none; 
			    font-weight: 400;
			}
			
			div a:hover {
				color: silver;
			 	text-decoration: underline; 
			}
			
			div a:visited {
				color: white;
			}
			
			div#container {
				text-align: center;
				width: 100%;
			}
			
		</style>
	</head>
	<body>

		<div class="info">
			liquid grotto simulator
		</div>
		
		<div class="notes">
			<b>todo:</b><br>
			render bubbles<br>
			sensor interactivity<br>
			game engine<br>
		</div>

		<div id="container"></div>

		<script src="three.js"></script>
		<script src="js/Detector.js"></script>
		<script src="js/controls/OrbitControls.js"></script>
		<script src="js/libs/stats.min.js"></script>

		<script>

			var container, stats;
			var camera, controls, scene, renderer;
			var pickingData = [], pickingTexture, pickingScene;
			var objects = [];
			var highlightBox;

			var mouse = new THREE.Vector2();
			var offset = new THREE.Vector3( 10, 10, 10 );

			var C = 300;
			var B = Math.sin(60*Math.PI/180.0) * C;
			var A = C * 0.5;
			
			var coordinates = [
				[-B, A],
				[-B, A-C],
				[0, -C],
				[B, A-C],
				[B, A],
				[0, C],	
							
				[-B*2, A*2],
				[-B*2, A*2-C],
				[-B*2, A*2-C*2],
				[-B, A-C*2],
				[0, -C*2],
				[B, A-C*2],
				[B*2, A*2-C*2],
				[B*2, A*2-C],
				[B*2, A*2],
				[B, A*3],
				[0, C*2],
				[-B, A*3],				

				[-B*3, A*3],
				[-B*3, A*3-C],
				[-B*3, A*3-C*2],
				[-B*3, A*3-C*3],
				[-B*2, A*2-C*3],
				[-B, A-C*3],
				[0, -C*3],
				[B, A-C*3],
				[B*2, A*2-C*3],
				[B*3, A*3-C*3],
				[B*3, A*3-C*2],
				[B*3, A*3-C],
				[B*3, A*3],
				[B*2, A*4],
				[B, A*5],
				[0, C*3],
				[-B, A*5],
				[-B*2, A*4],
			];
			
			var defaultMaterial = new THREE.MeshBasicMaterial({
				color: 0xffffff, 
				shading: THREE.SmoothShading, 
				vertexColors: THREE.VertexColors	
			});
			
			var tankMaterial = new THREE.MeshLambertMaterial({
				color: 0xffffff, 
				opacity: 0.65,
				transparent: true,
				shading: THREE.SmoothShading, 
				side: THREE.BackSide,
				vertexColors: THREE.VertexColors	
			});
			
			var stoneTexture = THREE.ImageUtils.loadTexture("stone.jpg");
			stoneTexture.wrapS = THREE.RepeatWrapping;
			stoneTexture.wrapT = THREE.RepeatWrapping;
			stoneTexture.repeat.set(80,30);
			
			var groundMaterial = new THREE.MeshBasicMaterial({
				color: 0x202015,
				depthTest : true,
				depthWrite : true,
				map : stoneTexture,
				transparency : 1.0,
				transparent : false,
				vertexColors : false,
				fog: true,
	
			});
			
			var pickingMaterial = new THREE.MeshBasicMaterial({
				vertexColors: THREE.VertexColors 
			});

			var highlightMaterial = new THREE.MeshBasicMaterial({
				color: 0xffff00, 
				opacity: 0.6, 
				transparent: true,
				side: THREE.BackSide 
			});
			
			var reflectionCube = THREE.ImageUtils.loadTextureCube([
				"panorama.jpg",
				"panorama.jpg",
				"black.jpg",
				"black.jpg",
				"panorama.jpg",
				"panorama.jpg",
			]);
			
			var shader = THREE.ShaderLib[ "cube" ];
			shader.uniforms[ "tCube" ].value = reflectionCube;

			var skyMaterial = new THREE.ShaderMaterial( {
				fragmentShader: shader.fragmentShader,
				vertexShader: shader.vertexShader,
				uniforms: shader.uniforms,
				depthWrite: false,
				side: THREE.BackSide
			});

			init();
			animate();
			
			function transform(geom, x, y, z) {
				var transM = new THREE.Matrix4();
				transM.makeTranslation(x, y, z);
				geom.applyMatrix(transM);
			}
			
			function applyGlobals(geom, position, rotation, scale) { 
				geom.position.copy(position);
				geom.rotation.copy(rotation);
				geom.scale.copy(scale);
			}
			
			function createTube(scene, position, rotation, scale) {
				var topHeight = 0.03;
				var bottomHeight = 0.3;
				
				var top = new THREE.CylinderGeometry(1, 1, topHeight, 20, 1);
				var bottom = new THREE.CylinderGeometry(1, 1.3, bottomHeight, 20, 1);
				var tank = new THREE.CylinderGeometry(1, 1, 1-topHeight-bottomHeight-0.001, 20, 1);
				
				transform(top, 0, 0.5-topHeight/2.0, 0);
				transform(bottom, 0, -0.5+bottomHeight/2.0, 0);
				transform(tank, 0, -0.5+bottomHeight+(1-topHeight-bottomHeight)/2.0, 0);

				var color = new THREE.Color( 0x202535 );
				
				var geom = new THREE.Geometry();
				THREE.GeometryUtils.merge(geom, top);
				THREE.GeometryUtils.merge(geom, bottom);
				applyVertexColors( geom, color );

				var shell = new THREE.Mesh( geom, defaultMaterial );
				
				applyGlobals(shell, position, rotation, scale);
				
				var tankMesh = new THREE.Mesh( tank, tankMaterial );
				applyGlobals(tankMesh, position, rotation, scale);
				
				scene.add(shell);
				scene.add(tankMesh);
								
				var c1 = new THREE.Color(1, 0, 0);
				c1.setHSL(0.7, 1.0, 0.5);
				var c2 = new THREE.Color(0, 1, 0);
				c2.setHSL(0.58, 1.0, 0.5);
				
				var topLight = new THREE.PointLight(c1.getHex(), 5.0, scale.y/15.0);
				var bottomLight = new THREE.PointLight(c2.getHex(), 5.0, scale.y/15.0);
				
				var topPosition = position.clone();
				topPosition.y = (0.5 - topHeight - 0.001) * scale.y;
				var bottomPosition = position.clone();
				bottomPosition.y = (-0.5 + bottomHeight + 0.001) * scale.y;

				applyGlobals(topLight, topPosition, rotation, scale);
				applyGlobals(bottomLight, bottomPosition, rotation, scale);
				
				scene.add(topLight);
				scene.add(bottomLight);
			}
			
			function applyVertexColors( g, c ) {
				g.faces.forEach( function( f ) {
					var n = ( f instanceof THREE.Face3 ) ? 3 : 4;
					for( var j = 0; j < n; j ++ ) {
						f.vertexColors[ j ] = c;
					}
				});
			}

			function init() {

				container = document.getElementById( "container" );

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.z = 1000;

				controls = new THREE.OrbitControls( camera );
				controls.rotateSpeed = 1.0;
				controls.zoomSpeed = 1.2;
				controls.panSpeed = 0.8;
				controls.noZoom = false;
				controls.noPan = true;
				controls.staticMoving = true;
				controls.dynamicDampingFactor = 0.3;
				controls.minDistance = 200;
				controls.maxDistance = 1800;
				controls.maxPolarAngle = Math.PI*0.499;

				scene = new THREE.Scene();

				pickingScene = new THREE.Scene();
				pickingTexture = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight );
				pickingTexture.generateMipmaps = false;

				//scene.add( new THREE.AmbientLight( 0x555555, 0.2 ) );

				var light = new THREE.SpotLight( 0xffffff, 0.9 );
				light.position.set( 0, 500, 2000 );
				//scene.add( light );				
				
				var ground = new THREE.Mesh(new THREE.PlaneGeometry(12000,12000), groundMaterial);
				ground.rotation.x = -Math.PI / 2;
				ground.position.y = -0.5 * 465;
				scene.add(ground);

				var skyMesh = new THREE.Mesh( new THREE.CubeGeometry( 12000, 12000, 12000 ), skyMaterial );
				scene.add( skyMesh );

				pickingGeometry = new THREE.Geometry();

				for ( var i = 0; i < coordinates.length; i ++ ) {

					var position = new THREE.Vector3();					
					position.set(coordinates[i][0], 0, coordinates[i][1]);
					
					var rotation = new THREE.Vector3();
					rotation.set(0,0,0);

					var scale = new THREE.Vector3();
					scale.set(15, 450, 15);
					
					createTube(scene, position, rotation, scale);
					
					// give the pickingGeom's vertices a color corresponding to the "id"
					var pickingGeom = new THREE.CylinderGeometry( 1, 1, 1, 20, 1 );
					var pickingColor = new THREE.Color( i );
					applyVertexColors( pickingGeom, pickingColor );

					var pickingCube = new THREE.Mesh( pickingGeom );
					pickingCube.position.copy( position );
					pickingCube.rotation.copy( rotation );
					pickingCube.scale.copy( scale );

					THREE.GeometryUtils.merge( pickingGeometry, pickingCube );

					pickingData[ i ] = {

						position: position,
						rotation: rotation,
						scale: scale

					};

				}

				pickingScene.add( new THREE.Mesh( pickingGeometry, pickingMaterial ) );

				highlightBox = new THREE.Mesh( 
					new THREE.CylinderGeometry( 0.8, 1.05, 1, 20, 1 ), 
					highlightMaterial
				);
				scene.add( highlightBox );

				projector = new THREE.Projector();

				if(Detector.webgl) {
	       			renderer = new THREE.WebGLRenderer({ antialias: true, clearColor: 0x000000 });
	       			renderer.sortObjects = false;
					renderer.setSize( window.innerWidth, window.innerHeight );

 	    		} else {
		  			renderer = new THREE.CanvasRenderer({ clearColor: 0x000000 });
		  			container.innerHTML = '<div style="padding: 20px; background-color: red; top: 200px; position: relative;"><a href="http://get.webgl.org">Oh no! Your browser does not appear to support WebGL, which is required for this simulator. Click here to find out more.</a></div>';
				}
				

				container.appendChild( renderer.domElement );

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );

				renderer.domElement.addEventListener( 'mousemove', onMouseMove );

			}

			//

			function onMouseMove( e ) {

				mouse.x = e.clientX;
				mouse.y = e.clientY;

			}

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();
				
				for(var i = 0; i < scene.__lights.length; i+=2) {
				    var lights = scene.__lights;
					var c0 = lights[i].color.getHSL();
					c0.h += 0.001;
					if (c0.h > 1) { c0.h = 0; }
					lights[i].color.setHSL(c0.h, c0.s, c0.l);
					var c1 = lights[i+1].color.getHSL();
					c1.h += 0.001;
					if (c1.h > 1) { c1.h = 0; }
					lights[i+1].color.setHSL(c1.h, c1.s, c1.l);
				}
			}

			function pick() {

				//render the picking scene off-screen

				renderer.setClearColorHex(0xffffff);
				renderer.render( pickingScene, camera, pickingTexture );
				renderer.setClearColorHex(0x000000);
				
				var gl = self.renderer.getContext();

				//read the pixel under the mouse from the texture

				var pixelBuffer = new Uint8Array( 4 );
				gl.readPixels( mouse.x, pickingTexture.height - mouse.y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixelBuffer );

				//interpret the pixel as an ID

				var id = ( pixelBuffer[0] << 16 ) | ( pixelBuffer[1] << 8 ) | ( pixelBuffer[2] );
				var data = pickingData[ id ];

				if (data) {

					//move our highlightBox so that it surrounds the picked object

					if ( data.position && data.rotation && data.scale ){

						highlightBox.position.copy( data.position );
						highlightBox.rotation.copy( data.rotation );
						highlightBox.scale.copy( data.scale ).add( offset );
						highlightBox.visible = true;

					}

				} else {

					highlightBox.visible = false;

				}

			}

			function render() {

				controls.update();

				pick();

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>